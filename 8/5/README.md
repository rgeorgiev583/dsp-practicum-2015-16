Задачи
======

1. Напишете програма, която прочита от стандартния вход израз от вида

    *израз* = *число* | *име*`(` (*израз*`, `)\* *израз*`)`

    т.е. имаме нещо подобно на вложени извиквания на функции в C/C++.
    Изведете извикванията на функциите (т.е. *име*(*изрази*)) по ред на
    оценяването им в рамките на израза (т.е. отвътре навън).

    **Пример:**

    *Вход:*

        minus(sqrt(add(multiply(cos(30), tan(60)), 1)), 2)

    *Изход:*

        30
        cos(30)
        60
        tan(60)
        multiply(cos(30), tan(60))
        1
        plus(multiply(cos(30), tan(60)), 1)
        sqrt(add(multiply(cos(30), tan(60)), 1))
        2
        minus(sqrt(add(multiply(cos(30), tan(60)), 1)), 2)


2. Напишете програма, която при получен *компресиран* низ на стандартния вход
   извежда на стандартния изход *декомпресираната* му версия.

    *Компресираният* израз се дефинира по следния начин:

    *израз* = ( *низ* | *число*`(`*израз*`)` )\*

    т.е. изразът съдържа конструкции от тип *число*(*низ*), които могат да
    влагат една в друга неограничен брой пъти.
    При декомпресиране всяка такава конструкция трябва да се замести с *низ*,
    повторен *число* на брой пъти, като спазваме нормалния приоритет на
    разкриване на скобите във формула.

    **Примери:**

    `A`                   -> `A`   
    `AB`                  -> `AB`  
    `2(AA)`               -> `AAAA`  
    `3(AB)`               -> `ABABAB`  
    `2(3(CD))`            -> `CDCDCDCDCDCD`  
    `3(EF2(GH))`          -> `EFGHGHEFGHGHEFGHGH`  
    `ABCD2(3(IJ)4(K)L)EF` -> `ABCDIJIJIJKKKKLIJIJIJKKKKLIJIJIJKKKKLEF`  

    **NB:** В програмата **НЯМАТЕ** право да използвате рекурсия.
